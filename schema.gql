schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

directive @ifAllowed on FIELD

enum Action {
  ACCEPT_EVENT_INVITE
  ADD_COMPETITION_JURY
  ADD_COMPETITION_MEMBER
  ADD_EVENT_COMPETITION
  ADD_EVENT_MEMBER
  AWARD_BADGE
  CREATE_BLOG_ARTICLE
  CREATE_COMMENT
  CREATE_COMPETITION
  CREATE_COMPETITION_RULE_AGREEMENT
  CREATE_COMPETITION_STAGE
  CREATE_COMPETITION_TEAM_REQUEST
  CREATE_DATASET
  CREATE_DATASET_COMPETITION
  CREATE_DATASET_MEMBER
  CREATE_DATASET_VERSION
  CREATE_EVENT
  CREATE_EVENT_RULE_AGREEMENT
  CREATE_FORUM
  CREATE_OAUTH_2_CONFIG
  CREATE_ORGANIZATION
  CREATE_PROJECT_VERSION_APPROVAL
  CREATE_SUBJECT_SUBSCRIPTION
  CREATE_SUBMISSION_VERSION
  CREATE_TAG
  CREATE_TOPIC
  CREATE_USE_CASE_VERSION
  DELETE_BLOG_ARTICLE
  DELETE_COMMENT
  DELETE_COMPETITION
  DELETE_COMPETITION_TEAM_REQUEST
  DELETE_DATASET
  DELETE_DATASET_COMPETITION
  DELETE_DATASET_MEMBER
  DELETE_DATASET_VERSION
  DELETE_EVENT
  DELETE_FORUM
  DELETE_OAUTH_2_CONFIG
  DELETE_ORGANIZATION
  DELETE_PROJECT_VERSION_APPROVAL
  DELETE_SUBJECT_SUBSCRIPTION
  DELETE_TAG
  DELETE_TOPIC
  DELETE_USER
  FETCH_WEBSITE_METADATA
  JOIN_COMPETITION
  JOIN_EVENT
  MANAGE_ENTITY_BAN
  MANAGE_EVENT_INVITE_CODE
  PUBLISH_DATASET_VERSION
  PUBLISH_VOTE
  READ_ACTIVITY_TRACKER
  READ_COMMENT
  READ_COMPETITION
  READ_COMPETITION_MEMBERSHIP
  READ_COMPETITION_PRIVATE_APPROVAL
  READ_COMPETITION_RULE
  READ_COMPETITION_RULE_AGREEMENT
  READ_COMPETITION_SCORING_CRITERION
  READ_DATASET
  READ_DATASET_MEMBER
  READ_DATASET_VERSION
  READ_DATASET_VERSION_FILE
  READ_EVENT
  READ_EVENT_COMPETITION
  READ_EVENT_INVITATION
  READ_EVENT_MEMBERSHIP
  READ_EVENT_RULE
  READ_EVENT_RULE_AGREEMENT
  READ_OAUTH_2_CONFIG
  READ_OAUTH_2_CONFIG_SECRET
  READ_PROJECT_VERSION
  READ_PROJECT_VERSION_APPROVAL
  READ_PROJECT_VERSION_APPROVAL_SCORE
  READ_PROJECT_VERSION_EVALUATION
  READ_PROJECT_VERSION_FILE
  READ_SUBJECT_SUBSCRIPTION
  READ_SUBMISSION
  READ_TOPIC
  READ_USER_EMAIL
  READ_USER_NOTIFICATIONS
  READ_USER_PERMISSIONS
  REEVALUATE_COMPETITION
  REMOVE_COMPETITION_JURY
  REMOVE_COMPETITION_MEMBER
  REMOVE_COMPETITION_STAGE
  REMOVE_EVENT_COMPETITION
  REMOVE_EVENT_MEMBER
  REMOVE_ORGANIZATION_MEMBER
  SEND_COMPETITION_TEAM_REQUEST_MESSAGE
  SET_COMPETITION_ORDERING_PRIORITY
  SET_EVENT_ORDERING_PRIORITY
  TRANSFER_COMPETITION_OWNERSHIP
  TRANSFER_DATASET_OWNERSHIP
  TRANSFER_EVENT_OWNERSHIP
  TRANSFER_ORGANIZATION_OWNERSHIP
  UPDATE_AGENDA
  UPDATE_BLOG_ARTICLE
  UPDATE_COMMENT
  UPDATE_COMPETITION
  UPDATE_COMPETITION_MEMBER
  UPDATE_COMPETITION_STAGE
  UPDATE_COMPETITION_TEAM_REQUEST
  UPDATE_DATASET
  UPDATE_DATASET_MEMBER
  UPDATE_DATASET_VERSION
  UPDATE_EVENT
  UPDATE_FORUM
  UPDATE_OAUTH_2_CONFIG
  UPDATE_ORGANIZATION
  UPDATE_ORGANIZATION_MEMBERSHIP
  UPDATE_PROJECT_VERSION
  UPDATE_PROJECT_VERSION_APPROVAL
  UPDATE_PROJECT_VERSION_FILE
  UPDATE_TOPIC
  UPDATE_USER
  UPLOAD_FILES
}

type Activity {
  date: NaiveDate!
  level: Int!
  points: Int!
}

type ActivityConnection {
  """A list of edges."""
  edges: [ActivityEdge!]!
  """A list of nodes."""
  nodes: [Activity!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ActivityEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Activity!
}

enum ActivityKind {
  ALL
  COMPETITION
  DATASET
}

enum ActivityVisibility {
  """Activity is visible by every authenticated user."""
  AUTHENTICATED
  """Activity is only visible to invited members."""
  MEMBERS
  """Activity is visible by everyone, even unauthenticated users."""
  UNAUTHENTICATED
}

enum ApprovalFilter {
  AWAITING_ANY
  AWAITING_MINE
  HAS_ANY
  HAS_MINE
}

enum ArchiveKind {
  TAR
  ZIP
}

enum Badge {
  """BIG Quantum Hackathon by QuantX, October 2021, Paris (FR)"""
  BIG_PARIS_2021
  """
  BIG Quantum Hackathon by the Chicago Quantum Exchange & QuantX, Sept 2023, Chicago (USA)
  """
  CHICAGO_2023
  """Winner of the EPRI 2025 Challenge"""
  EPRI2025_FIRST
  """Runner-Up of the EPRI 2025 Challenge"""
  EPRI2025_SECOND
  """Finalist of the EPRI 2025 Challenge"""
  EPRI2025_THIRD
  """Winner of GIC-2025 JPMorgan Chase Challenge"""
  GIC2025_JPMC
  """Winner of GIC-2025 MITRE Challenge"""
  GIC2025_MITRE
  """Winner of GIC-2025 NeuroQuantum Nexus Challenge"""
  GIC2025_NEURO_QUANTUM
  """Winner GIC-2025 Wells Fargo Challenge"""
  GIC2025_WELLS_FARGO
  """Winner of GIC-2025 The World Bank Challenge"""
  GIC2025_WORLD_BANK
  """Quantum Hackathon by QuantX, October 2022, Grenoble (FR)"""
  GRENOBLE_2022
  """Clinical Trial Optimization Competition 2024 by Ingenii First Prize"""
  INGENII_2024_FIRST
  """Clinical Trial Optimization Competition 2024 by Ingenii Participant"""
  INGENII_2024_OTHERS
  """Clinical Trial Optimization Competition 2024 by Ingenii Second Prize"""
  INGENII_2024_SECOND
  """Clinical Trial Optimization Competition 2024 by Ingenii Special Prize"""
  INGENII_2024_SPECIAL
  """Clinical Trial Optimization Competition 2024 by Ingenii Third Prize"""
  INGENII_2024_THIRD
  """
  Quantum Hackathon by Québec Quantique & QuantX, June 2022, Montreal (CAN)
  """
  MONTREAL_2022
  """Malicious Login Detection 2024 by NovaceneAI – Winner"""
  NOVACENE_2024
  """Quantum hackathon by QuantX, March 2021, Paris (FR)"""
  PARIS_2021
  """BIG QC-AI-HPC Hackathon by QuantX, March 2023, Paris (FR)"""
  PARIS_2023
  """
  BIG Quantum Hackathon Sports Edition by QuantX & Aqora, May 2024, Paris (FR)
  """
  PARIS_2024_HACKERS
  """
  BIG Quantum Hackathon Sports Edition by QuantX & Aqora, May 2024, Paris (FR)
  """
  PARIS_2024_WINNERS
  """Hackathon Trailblazer - 3rd Place Team - Q2B Silicon Valley 2024"""
  Q2B2024_BRONZE
  """Hackathon Champion - Q2B Silicon Valley 2024"""
  Q2B2024_GOLD
  """On-Site Participant - Q2B Hackathon 2024"""
  Q2B2024_ONSITE
  """Global Participant - Q2B Hackathon 2024"""
  Q2B2024_REMOTE
  """Hackathon Innovator - 2nd Place Team - Q2B Silicon Valley 2024"""
  Q2B2024_SILVER
  """QInnovision Challenge 2024-2025 Finalist!"""
  QINNOVISION_2025_FINALIST
  """QInnovision Challenge 2024-2025 Winner!"""
  QINNOVISION_2025_WINNER
  """QML Summer School 2025"""
  QML_SUMMER_SCHOOL_2025
  """Badge awarded upon first submission"""
  QUANTUM_PIONEER
  """Quantum Trading Oracle  – 1st Place"""
  QUANTUM_SIGNALS_LOB_2025_FIRST
  """Schrödinger’s Trader – 2nd Place - Second Prize"""
  QUANTUM_SIGNALS_LOB_2025_SECOND
  TEST
  """ICTP - Quantinuum Quantum Hackathon, April 2023, Trieste (IT)"""
  TRIESTE_2023
}

type Blog implements ForumOwner {
  forum: Forum!
  forumOwnerKind: ForumOwnerKind!
  id: ID!
  slug: String!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type BlogArticle implements Node {
  authors(after: String, before: String, first: Int, last: Int): BlogArticleAuthorConnection!
  blurHash: String
  content: String
  createdAt: DateTime!
  id: ID!
  image: Url
  imageAlt: String
  seoDescription: String
  seoTitle: String
  shortDescription: String!
  slugLower: String!
  title: String!
  topic: Topic!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type BlogArticleAuthorConnection {
  """A list of edges."""
  edges: [BlogArticleAuthorConnectionEdge!]!
  """A list of nodes."""
  nodes: [Entity!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type BlogArticleAuthorConnectionEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Entity!
}

type BlogArticleConnection {
  """A list of edges."""
  edges: [BlogArticleEdge!]!
  """A list of nodes."""
  nodes: [BlogArticle!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type BlogArticleEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: BlogArticle!
}

type Comment implements Node & Votable {
  author: User!
  children(after: String, before: String, first: Int, last: Int, order: VotableOrder): CommentConnection!
  content: String!
  createdAt: DateTime!
  edited: Boolean!
  id: ID!
  numChildren: Int!
  parent: Comment
  topic: Topic!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
  voted: EntityVote
  voterCount: Int!
  voters(after: String, before: String, first: Int, last: Int): VotersConnection!
  votes: Int!
}

type CommentConnection {
  """A list of edges."""
  edges: [CommentEdge!]!
  """A list of nodes."""
  nodes: [Comment!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type CommentEdge {
  """A cursor for use in pagination"""
  cursor: String!
  hotness: Float!
  """The item at the end of the edge"""
  node: Comment!
}

type Competition implements ForumOwner & Node & Subscribable {
  banner: Url
  createdAt: DateTime!
  currentStage: CompetitionStage!
  datasets(after: String, before: String, first: Int, last: Int): CompetitionDatasetConnection!
  description: String
  entityRuleAgreements(after: String, before: String, entity: UsernameOrID, first: Int, last: Int, latest: Boolean): CompetitionRuleAgreementConnection!
  entitySubscription(entity: UsernameOrID): SubjectSubscription
  forum: Forum!
  forumOwnerKind: ForumOwnerKind!
  hasLeaderboard: Boolean!
  hasSubmissions: Boolean!
  host: Entity!
  id: ID!
  isPrivate: Boolean!
  jury(after: String, before: String, first: Int, last: Int): CompetitionJuryConnection!
  latestRule: CompetitionRule!
  leaderboard(after: String, before: String, first: Int, last: Int, stage: Int): SubmissionRankingConnection!
  members(after: String, before: String, first: Int, last: Int, search: String): CompetitionMembershipConnection!
  membership(entity: UsernameOrID): CompetitionMembership
  requiresApproval: Boolean!
  rules(after: String, before: String, first: Int, last: Int): CompetitionRuleConnection!
  shortDescription: String!
  showMetric: Boolean! @deprecated(reason: "Use currentStage.showMetric instead")
  slug: String!
  stage(stage: Int): CompetitionStage
  stages(after: String, before: String, first: Int, hasLeaderboard: Boolean, last: Int, requiresApproval: Boolean): CompetitionStageConnection!
  submission(entity: UsernameOrID): Submission
  submissions(after: String, approvalFilter: ApprovalFilter, before: String, entityId: ID, first: Int, last: Int, stage: Int): SubmissionConnection!
  tags(after: String, before: String, first: Int, last: Int): CompetitionTagConnection!
  teamRequests(after: String, before: String, first: Int, isOrganization: Boolean, last: Int): CompetitionTeamRequestConnection!
  thumbnail: Url
  timeline: Timeline
  title: String!
  useCase: UseCase!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
  visibility: ActivityVisibility!
}

type CompetitionConnection {
  """A list of edges."""
  edges: [CompetitionEdge!]!
  """A list of nodes."""
  nodes: [Competition!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type CompetitionDatasetConnection {
  """A list of edges."""
  edges: [CompetitionDatasetConnectionEdge!]!
  """A list of nodes."""
  nodes: [Dataset!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type CompetitionDatasetConnectionEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Dataset!
}

"""An edge in a connection."""
type CompetitionEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Competition!
}

type CompetitionJuryConnection {
  """A list of edges."""
  edges: [CompetitionJuryEdge!]!
  """A list of nodes."""
  nodes: [Entity!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type CompetitionJuryEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Entity!
  selectedOn: DateTime!
}

type CompetitionMembership implements Node {
  asEntity: Entity!
  competition: Competition!
  createdAt: DateTime!
  entity: Entity!
  id: ID!
  kind: CompetitionMembershipKind!
  ruleAgreements(after: String, before: String, first: Int, last: Int, latest: Boolean): CompetitionRuleAgreementConnection!
  teamRequest: CompetitionTeamRequest
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type CompetitionMembershipConnection {
  """A list of edges."""
  edges: [CompetitionMembershipEdge!]!
  """A list of nodes."""
  nodes: [CompetitionMembership!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type CompetitionMembershipEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: CompetitionMembership!
}

enum CompetitionMembershipKind {
  HOST
  PARTICIPANT
}

type CompetitionRule implements Node {
  competition: Competition!
  createdAt: DateTime!
  entityAgreement(entity: UsernameOrID): CompetitionRuleAgreement
  id: ID!
  text: String!
}

type CompetitionRuleAgreement implements Node {
  competitionRule: CompetitionRule!
  createdAt: DateTime!
  entity: Entity!
  id: ID!
}

type CompetitionRuleAgreementConnection {
  """A list of edges."""
  edges: [CompetitionRuleAgreementEdge!]!
  """A list of nodes."""
  nodes: [CompetitionRuleAgreement!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type CompetitionRuleAgreementEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: CompetitionRuleAgreement!
}

type CompetitionRuleConnection {
  """A list of edges."""
  edges: [CompetitionRuleEdge!]!
  """A list of nodes."""
  nodes: [CompetitionRule!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type CompetitionRuleEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: CompetitionRule!
}

type CompetitionScoringCriterion implements Node {
  competition: Competition!
  description: String
  id: ID!
  order: Int!
  stage: CompetitionStage!
  title: String!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
  weight: Float!
}

type CompetitionStage implements Node {
  competition: Competition!
  createdAt: DateTime!
  hasLeaderboard: Boolean!
  id: ID!
  isActive: Boolean!
  leaderboard(after: String, before: String, first: Int, last: Int): SubmissionRankingConnection!
  noCode: Boolean!
  privateApprovals: Boolean!
  requiresApproval: Boolean!
  scoringCriteria: [CompetitionScoringCriterion!]!
  seq: Int!
  showMetric: Boolean!
  submission(entity: UsernameOrID): Submission
  submissionPreamble: String
  submissions(after: String, before: String, first: Int, last: Int): SubmissionConnection!
  useJuryScore: Boolean!
  validUntil: DateTime
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type CompetitionStageConnection {
  """A list of edges."""
  edges: [CompetitionStageEdge!]!
  """A list of nodes."""
  nodes: [CompetitionStage!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type CompetitionStageEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: CompetitionStage!
}

type CompetitionSubscription implements Node & SubjectSubscription {
  competition: Competition!
  createdAt: DateTime!
  entity: Entity!
  id: ID!
  kind: SubjectKind!
  subject: Subscribable!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type CompetitionTagConnection {
  """A list of edges."""
  edges: [TagEdge!]!
  """A list of nodes."""
  nodes: [Tag!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type CompetitionTeamRequest implements Node {
  competition: Competition!
  createdAt: DateTime!
  entity: Entity!
  id: ID!
  lastMessageAt: DateTime
  needs: String!
  skills: String!
  timezone: TimeZone!
  updatedAt: DateTime!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type CompetitionTeamRequestConnection {
  """A list of edges."""
  edges: [CompetitionTeamRequestEdge!]!
  """A list of nodes."""
  nodes: [CompetitionTeamRequest!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type CompetitionTeamRequestEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: CompetitionTeamRequest!
}

input CreateBlogArticleInput {
  authorsIds: [ID!]!
  content: String!
  image: Upload
  imageAlt: String
  seoDescription: String
  seoTitle: String
  shortDescription: String!
  title: String!
}

input CreateCommentInput {
  content: String!
}

input CreateCompetitionInput {
  banner: Upload
  description: String
  """Enables no-code system on competition. Requires jury system to work."""
  noCode: Boolean! = false
  """
  Only allow the competition host, the reviewer and the submission author to see the approval
  score.
  """
  privateApprovals: Boolean! = true
  """Enables jury system on competition"""
  requiresApproval: Boolean! = false
  shortDescription: String!
  """Show automated use-case metric."""
  showMetric: Boolean! = true
  slug: String!
  """Message shown to participants before they submit a solution."""
  submissionPreamble: String = null
  tagIds: [ID]
  thumbnail: Upload
  timeline: CreateTimelineInput
  title: String!
  """
  Use average jury score instead of automated use-case metric. Requires jury system to work.
  """
  useJuryScore: Boolean! = false
  visibility: ActivityVisibility! = UNAUTHENTICATED
}

input CreateCompetitionStageInput {
  """Enables no-code system on competition. Requires jury system to work."""
  noCode: Boolean! = false
  """
  Only allow the competition host, the reviewer and the submission author to see the approval
  score.
  """
  privateApprovals: Boolean! = true
  """Enables jury system on competition"""
  requiresApproval: Boolean! = false
  """Show automated use-case metric."""
  showMetric: Boolean! = true
  """Message shown to participants before they submit a solution."""
  submissionPreamble: String = null
  """
  Use average jury score instead of automated use-case metric. Requires jury system to work.
  """
  useJuryScore: Boolean! = false
}

input CreateCompetitionTeamRequestInput {
  needs: String!
  skills: String!
  timezone: TimeZone!
}

input CreateDatasetInput {
  localSlug: String!
  name: String!
  private: Boolean!
  shortDescription: String
  tags: [ID!]!
}

input CreateDatasetVersionInput {
  datasetVersionId: ID
  version: Semver
}

input CreateEventInput {
  banner: Upload
  description: String
  shortDescription: String!
  slug: String!
  thumbnail: Upload
  title: String!
  visibility: ActivityVisibility! = UNAUTHENTICATED
}

input CreateForumInput {
  description: String
  guidelines: String
  icon: Upload
  orderingPriority: Int
  shortDescription: String!
  slug: String!
  title: String!
}

type CreateMultipartUploadResponse {
  uploadId: String!
  urls: [Url!]!
}

input CreateOauth2ConfigInput {
  description: String
  name: String!
  redirectUri: Url!
}

input CreateOrganizationInput {
  bio: String
  displayName: String!
  github: String
  googleScholar: String
  image: Upload
  linkedin: String
  location: String
  username: String!
  website: Url
}

input CreatePasswordResetInput {
  usernameOrEmail: String!
}

input CreateTagInput {
  name: String!
}

input CreateTimelineInput {
  endDate: NaiveDate!
  online: Boolean!
  startDate: NaiveDate!
  steps: [TimelineStepInput!]!
  timezone: TimeZone!
}

input CreateTopicInput {
  description: String
  title: String!
  url: Url
}

type DOI {
  full: String!
  short: String
  url: Url!
}

type Dataset implements ForumOwner & Node & Votable {
  analytics: DatasetAnalytics!
  competitions(after: String, before: String, first: Int, last: Int, search: String): DatasetCompetitionConnection!
  createdAt: DateTime!
  forum: Forum!
  forumOwnerKind: ForumOwnerKind!
  id: ID!
  latestVersion: DatasetVersion
  localSlug: String!
  members(after: String, before: String, first: Int, last: Int, search: String): DatasetMembershipConnection!
  name: String!
  owner: Entity!
  private: Boolean!
  publiclyIdentified: Boolean!
  shortDescription: String
  slug: String!
  tags(after: String, before: String, first: Int, last: Int): DatasetTagConnection!
  version(major: Int!, minor: Int!, patch: Int!): DatasetVersion
  versions(after: String, before: String, filters: DatasetVersionQueryFilters, first: Int, last: Int): DatasetVersionConnection!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
  voted: EntityVote
  voterCount: Int!
  voters(after: String, before: String, first: Int, last: Int): VotersConnection!
  votes: Int!
}

type DatasetAnalytics {
  downloadCount: Int!
  fileSize: Int!
  rowCount: Int!
}

type DatasetCompetitionConnection {
  """A list of edges."""
  edges: [DatasetCompetitionConnectionEdge!]!
  """A list of nodes."""
  nodes: [Competition!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type DatasetCompetitionConnectionEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Competition!
}

type DatasetConnection {
  """A list of edges."""
  edges: [DatasetEdge!]!
  """A list of nodes."""
  nodes: [Dataset!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  size: DatasetSize!
  totalCount: Int!
}

enum DatasetConnectionOrder {
  CREATED_AT
  DOWNLOADS
  TRENDING
}

enum DatasetConnectionSortDirection {
  ASCENDING
  DESCENDING
}

"""An edge in a connection."""
type DatasetEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Dataset!
}

type DatasetMembershipConnection {
  """A list of edges."""
  edges: [DatasetMembershipConnectionEdge!]!
  """A list of nodes."""
  nodes: [Entity!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type DatasetMembershipConnectionEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Entity!
}

"""At least one field must be set."""
input DatasetQueryFilterSize {
  high: Int
  low: Int
}

input DatasetQueryFilters {
  order: DatasetConnectionOrder! = CREATED_AT
  search: String
  size: DatasetQueryFilterSize
  sortDirection: DatasetConnectionSortDirection! = DESCENDING
  tags: [ID!]
}

type DatasetSize {
  high: Int!
  low: Int!
}

type DatasetTagConnection {
  """A list of edges."""
  edges: [DatasetTagConnectionEdge!]!
  """A list of nodes."""
  nodes: [Tag!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  totalCount: Int!
}

"""An edge in a connection."""
type DatasetTagConnectionEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Tag!
}

type DatasetVersion implements Node {
  analytics: DatasetAnalytics!
  authors(after: String, before: String, first: Int, last: Int, search: String): DatasetVersionAuthorConnection!
  createdAt: DateTime!
  dataset: Dataset!
  description: String!
  doi: DOI
  fileByPartitionNum(partitionNum: Int!): DatasetVersionFile
  files(after: String, before: String, first: Int, last: Int): DatasetVersionFileConnection!
  id: ID!
  license: String
  publishable: Boolean!
  publishedAt: DateTime
  records(limit: Int! = 100, offset: Int! = 0): [JSON!]!
  rows: Int!
  schema: JSON
  size: Int!
  updatedAt: DateTime!
  version: Semver!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

interface DatasetVersionAuthor {
  displayName: String!
}

type DatasetVersionAuthorConnection {
  """A list of edges."""
  edges: [DatasetVersionAuthorConnectionEdge!]!
  """A list of nodes."""
  nodes: [DatasetVersionAuthor!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  totalCount: Int!
}

"""An edge in a connection."""
type DatasetVersionAuthorConnectionEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: DatasetVersionAuthor!
}

input DatasetVersionAuthorInput {
  registered: UsernameOrID
  unregistered: UnregisteredDatasetVersionAuthorInput
}

type DatasetVersionConnection {
  """A list of edges."""
  edges: [DatasetVersionEdge!]!
  """A list of nodes."""
  nodes: [DatasetVersion!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  totalCount: Int!
}

enum DatasetVersionConnectionOrder {
  CREATED_AT
  PUBLISHED_AT
  UPDATED_AT
}

enum DatasetVersionConnectionSortDirection {
  ASCENDING
  DESCENDING
}

"""An edge in a connection."""
type DatasetVersionEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: DatasetVersion!
}

type DatasetVersionFile implements Node {
  datasetVersion: DatasetVersion!
  id: ID!
  partitionNum: Int!
  records(limit: Int! = 100, offset: Int! = 0): [JSON!]!
  rows: Int!
  size: Int!
  url: Url!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type DatasetVersionFileConnection {
  """A list of edges."""
  edges: [DatasetVersionFileEdge!]!
  """A list of nodes."""
  nodes: [DatasetVersionFile!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type DatasetVersionFileEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: DatasetVersionFile!
}

input DatasetVersionQueryFilters {
  order: DatasetVersionConnectionOrder! = CREATED_AT
  published: Boolean = null
  sortDirection: DatasetVersionConnectionSortDirection! = DESCENDING
}

enum DatasetVersionStatus {
  GENERATING_DOI
  IDLE
}

type DatasetVersionUpdate {
  datasetVersion: DatasetVersion!
  status: DatasetVersionStatus!
}

"""
Implement the DateTime<FixedOffset> scalar

The input/output is a string in RFC3339 format.
"""
scalar DateTime

type DeletedComment {
  commentId: ID!
  parentId: ID
  topicId: ID!
}

type EmailSignupRequest implements Node {
  emailCanResendAt: DateTime!
  emailSentCount: Int!
  expiresAt: DateTime!
  id: ID!
  lastEmailSentAt: DateTime!
}

input EmailSignupVerficationInput {
  id: ID!
  token: String!
}

interface Entity {
  badges(after: String, before: String, first: Int, last: Int): EntityBadgeConnection!
  bio: String
  createdAt: DateTime!
  datasets(after: String, before: String, filters: DatasetQueryFilters, first: Int, last: Int): DatasetConnection!
  displayName: String!
  github: String
  googleScholar: String
  id: ID!
  image: Url
  imageThumbnail: Url
  kind: EntityKind!
  linkedin: String
  location: String
  points: Int!
  projectVersionApprovals(after: String, before: String, first: Int, last: Int, projectVersionId: UUID): ProjectVersionApprovalConnection!
  rank: Int!
  subjectSubscriptions(after: String, before: String, first: Int, kinds: [SubjectKind!], last: Int): SubjectSubscriptionConnection!
  submissions(after: String, allStages: Boolean, before: String, competitionId: ID, first: Int, last: Int): SubmissionConnection!
  username: String!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
  website: String
}

enum EntityActivitiesConnectionKind {
  COMMENT
  DATASET
  SUBMISSION
  TOPIC
}

type EntityBadge implements Node {
  badge: Badge!
  createdAt: DateTime!
  id: ID!
}

type EntityBadgeConnection {
  """A list of edges."""
  edges: [EntityBadgeEdge!]!
  """A list of nodes."""
  nodes: [EntityBadge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type EntityBadgeEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: EntityBadge!
}

type EntityConnection {
  """A list of edges."""
  edges: [EntityEdge!]!
  """A list of nodes."""
  nodes: [Entity!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type EntityEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Entity!
}

enum EntityKind {
  ORGANIZATION
  USER
}

type EntityVote {
  score: Int!
  subject: VotableEdge!
  votedAt: DateTime!
}

type Event implements ForumOwner & Node {
  agenda: JSON
  banner: Url
  competitions(after: String, before: String, first: Int, last: Int): EventCompetitionConnection!
  createdAt: DateTime!
  description: String
  entityRuleAgreements(after: String, before: String, entity: UsernameOrID, first: Int, last: Int, latest: Boolean): EventRuleAgreementConnection!
  forum: Forum!
  forumOwnerKind: ForumOwnerKind!
  host: Entity!
  id: ID!
  invitations(after: String, before: String, first: Int, last: Int): EventInvitationConnection!
  invite: EventPublicInvite!
  isPrivate: Boolean!
  latestRule: EventRule!
  members(after: String, before: String, first: Int, last: Int, search: String): EventMembershipConnection!
  membership(entity: UsernameOrID): EventMembership
  rules(after: String, before: String, first: Int, last: Int): EventRuleConnection!
  shortDescription: String!
  slug: String!
  teams(after: String, before: String, first: Int, last: Int): OrganizationConnection!
  thumbnail: Url
  title: String!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
  visibility: ActivityVisibility!
}

type EventCompetition implements Node {
  competition: Competition!
  event: Event!
  id: ID!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type EventCompetitionConnection {
  """A list of edges."""
  edges: [EventCompetitionEdge!]!
  """A list of nodes."""
  nodes: [EventCompetition!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type EventCompetitionEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: EventCompetition!
}

type EventConnection {
  """A list of edges."""
  edges: [EventEdge!]!
  """A list of nodes."""
  nodes: [Event!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type EventEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Event!
}

type EventInvitation implements Node {
  email: String!
  event: Event!
  id: ID!
  organization: Organization
  registeredAs: User
  username: String
}

type EventInvitationConnection {
  """A list of edges."""
  edges: [EventInvitationEdge!]!
  """A list of nodes."""
  nodes: [EventInvitation!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  totalCount: Int!
}

"""An edge in a connection."""
type EventInvitationEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: EventInvitation!
}

interface EventInvite {
  event: Event!
  id: ID!
  latestRuleText: String!
  shortDescription: String!
  thumbnail: Url
  title: String!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

input EventMemberInvite {
  """
  Required email used to find registered members, or send invitation email otherwise.
  """
  email: String!
  """Optional team name used to create teams for the event."""
  team: String
  """
  Optional username used to send invitation email when the member has not registered yet.
  """
  username: String
}

type EventMembership implements Node {
  entity: Entity!
  event: Event!
  id: ID!
  kind: EventMembershipKind!
  ruleAgreements(after: String, before: String, first: Int, last: Int, latest: Boolean): EventRuleAgreementConnection!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type EventMembershipConnection {
  """A list of edges."""
  edges: [EventMembershipEdge!]!
  """A list of nodes."""
  nodes: [EventMembership!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type EventMembershipEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: EventMembership!
}

enum EventMembershipKind {
  HOST
  PARTICIPANT
}

type EventPrivateInvite implements EventInvite & Node {
  event: Event!
  id: ID!
  latestRuleText: String!
  shortDescription: String!
  thumbnail: Url
  title: String!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type EventPublicInvite implements EventInvite & Node {
  code: String
  event: Event!
  id: ID!
  latestRuleText: String!
  shortDescription: String!
  thumbnail: Url
  title: String!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type EventRule implements Node {
  createdAt: DateTime!
  entityAgreement(entity: UsernameOrID): EventRuleAgreement
  event: Event!
  id: ID!
  text: String!
}

type EventRuleAgreement implements Node {
  createdAt: DateTime!
  entity: Entity!
  eventRule: EventRule!
  id: ID!
}

type EventRuleAgreementConnection {
  """A list of edges."""
  edges: [EventRuleAgreementEdge!]!
  """A list of nodes."""
  nodes: [EventRuleAgreement!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type EventRuleAgreementEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: EventRuleAgreement!
}

type EventRuleConnection {
  """A list of edges."""
  edges: [EventRuleEdge!]!
  """A list of nodes."""
  nodes: [EventRule!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type EventRuleEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: EventRule!
}

type FileBrowser {
  readDir(after: String, first: Int, path: String): FileBrowserEntryConnection!
  readMeta(path: String): FileBrowserEntry
}

type FileBrowserDirectoryEntry implements FileBrowserEntry {
  kind: FileBrowserEntryKind!
  name: String!
}

interface FileBrowserEntry {
  kind: FileBrowserEntryKind!
  name: String!
}

type FileBrowserEntryConnection {
  """A list of edges."""
  edges: [FileBrowserEntryEdge!]!
  """A list of nodes."""
  nodes: [FileBrowserEntry!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type FileBrowserEntryEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: FileBrowserEntry!
}

enum FileBrowserEntryKind {
  DIRECTORY
  FILE
}

type FileBrowserFileEntry implements FileBrowserEntry {
  contentLength: Int!
  contentType: String!
  downloadUrl: Url!
  kind: FileBrowserEntryKind!
  mode: Int!
  name: String!
}

type FinishUploadFile {
  downloadUrl: Url!
}

input FinishUploadFileInput {
  key: String!
}

type Forum implements ForumOwner & Node & Subscribable {
  createdAt: DateTime!
  description: String
  entitySubscription(entity: UsernameOrID): SubjectSubscription
  forum: Forum!
  forumOwnerKind: ForumOwnerKind!
  guidelines: String
  icon: Url
  id: ID!
  orderingPriority: Int!
  owner: ForumOwner!
  shortDescription: String!
  slug: String!
  title: String!
  topics(after: String, before: String, first: Int, last: Int, order: VotableOrder): TopicConnection!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type ForumConnection {
  """A list of edges."""
  edges: [ForumEdge!]!
  """A list of nodes."""
  nodes: [Forum!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ForumEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Forum!
}

interface ForumOwner {
  forum: Forum!
  forumOwnerKind: ForumOwnerKind!
  id: ID!
  slug: String!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

enum ForumOwnerKind {
  BLOG
  COMPETITION
  DATASET
  EVENT
  TOP_LEVEL
}

type ForumSubscription implements Node & SubjectSubscription {
  createdAt: DateTime!
  entity: Entity!
  forum: Forum!
  id: ID!
  kind: SubjectKind!
  subject: Subscribable!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type GlobalLeaderboardConnection {
  """A list of edges."""
  edges: [GlobalLeaderboardEdge!]!
  """A list of nodes."""
  nodes: [Entity!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type GlobalLeaderboardEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Entity!
  points: Int!
  rank: Int!
}

type InitUploadFile {
  key: String!
  uploadUrl: Url!
}

input InitUploadFileInput {
  contentLength: Int!
  contentType: String!
  filename: String!
}

"""A scalar that can represent any JSON value."""
scalar JSON

input LoginUserInput {
  password: String!
  usernameOrEmail: String!
}

type Mutation {
  acceptEventInvite(asEntity: UsernameOrID, code: String, id: ID!): EventInvite!
  addCompetitionJury(competitionId: ID!, entityId: ID!): CompetitionJuryEdge!
  addCompetitionMember(competitionId: ID!, entityId: ID!): CompetitionMembershipEdge!
  addDatasetCompetition(competitionId: ID!, datasetId: ID!): DatasetCompetitionConnectionEdge!
  addDatasetMember(datasetId: ID!, entityId: ID!): DatasetMembershipConnectionEdge!
  addEventCompetition(competitionId: ID!, eventId: ID!): EventCompetitionEdge!
  addEventMember(entityId: ID!, eventId: ID!): EventMembershipEdge!
  agreeToCompetitionRule(asEntity: UsernameOrID, competition: ID!): CompetitionRuleAgreement!
  agreeToEventRule(asEntity: UsernameOrID, event: ID!): EventRuleAgreement!
  awardBadge(badge: Badge!, entityId: ID!): EntityBadgeEdge!
  checkEmailSignupVerification(input: EmailSignupVerficationInput!): EmailSignupRequest!
  checkOauth2Auth(code: String!, state: String!): Oauth2AuthResponse!
  """
  Finalize the upload of a file attached to a dataset version.
  Must be called exactly one time.
  If not called, all uploaded files get garbage collected 6 hours after
  the last part was uploaded.
  """
  completeDatasetVersionFile(datasetVersionFileId: ID!, eTags: [String!]!): DatasetVersionFile!
  completeProjectVersionFileMultipartUpload(eTags: [String!]!, id: ID!, uploadId: String!): ProjectVersionFile!
  createBlogArticle(input: CreateBlogArticleInput!): BlogArticleEdge!
  createCommentForComment(commentId: ID!, input: CreateCommentInput!): CommentEdge!
  createCommentForTopic(input: CreateCommentInput!, topicId: ID!): CommentEdge!
  createCompetition(input: CreateCompetitionInput!): CompetitionEdge!
  """
  Archive currently active leaderboard into a new stage, creating a new empty leaderboard.
  Returns previously active leaderboard.
  """
  createCompetitionStage(competitionId: ID!, input: CreateCompetitionStageInput!): CompetitionStageEdge!
  createCompetitionTeamRequest(competitionId: ID!, input: CreateCompetitionTeamRequestInput!): CompetitionTeamRequestEdge!
  createDataset(asEntity: UsernameOrID, input: CreateDatasetInput!): Dataset!
  """
  Creates a new dataset version:
  inheriting and bumping SemVer with a payload,
  or creating a fresh version if none provided.
  """
  createDatasetVersion(datasetId: ID!, input: CreateDatasetVersionInput): DatasetVersion!
  """
  Attach a file to a dataset version. Returns an upload ID which you can use
  to call `uploadDatasetVersionFilePart`.
  """
  createDatasetVersionFile(datasetVersionId: ID!, partitionNum: Int!): ID!
  createEvent(input: CreateEventInput!): EventEdge!
  createForum(input: CreateForumInput!): ForumEdge!
  createOauth2AuthRequest(provider: Oauth2Provider!): Url!
  createOauth2Config(asEntity: UsernameOrID, input: CreateOauth2ConfigInput!): Oauth2ConfigEdge!
  createOrganization(input: CreateOrganizationInput!): OrganizationEdge!
  createPasswordReset(input: CreatePasswordResetInput!): PasswordReset!
  createProjectVersionApproval(input: ProjectVersionApprovalInput!, projectVersionId: ID!): ProjectVersionApprovalEdge!
  createProjectVersionFileMultipartUpload(id: ID!): CreateMultipartUploadResponse!
  createSubmissionVersion(asEntity: UsernameOrID, competitionId: ID!, input: UpdateSubmissionInput!): ProjectVersionEdge!
  createTag(entityId: ID!, input: CreateTagInput!): TagEdge!
  createTopic(forumId: ID!, input: CreateTopicInput!): TopicEdge!
  createUseCaseVersion(competitionId: ID!, input: UpdateUseCaseInput!): ProjectVersionEdge!
  deleteBlogArticle(id: ID!): ID!
  deleteComment(id: ID!): ID!
  deleteCompetition(id: ID!): ID!
  deleteCompetitionTeamRequest(competitionTeamRequestId: ID!): ID!
  deleteDataset(datasetId: ID!): ID!
  deleteDatasetVersion(datasetVersionId: ID!): ID!
  deleteEvent(id: ID!): ID!
  deleteForum(id: ID!): ID!
  deleteOauth2Config(oauth2ConfigId: ID!): ID!
  deleteOrganization(id: ID!): ID!
  deleteProjectVersionApproval(projectVersionApprovalId: ID!): ID!
  deleteTag(tagId: ID!): ID!
  deleteTopic(id: ID!): ID!
  deleteUser(id: ID!): ID!
  fetchWebsiteMetadata(url: Url!): WebsiteMetadata!
  finishDatasetVersionUpload(datasetVersionId: ID!): DatasetVersion!
  finishUploadFile(input: FinishUploadFileInput!): FinishUploadFile!
  generateEventInviteCode(id: ID!): EventPublicInvite!
  initUploadFile(input: InitUploadFileInput!): InitUploadFile!
  inviteEventMembers(eventId: ID!, invites: [EventMemberInvite!]!): Event!
  joinCompetition(asEntity: UsernameOrID, competitionId: ID!): CompetitionMembershipEdge!
  joinEvent(asEntity: UsernameOrID, eventId: ID!): EventMembershipEdge!
  loginUser(input: LoginUserInput!): UserEdge!
  logoutUser: Boolean!
  oauth2Authorize(consent: Boolean! = true, input: Oauth2AuthorizeInput!): Oauth2AuthorizeOutput!
  oauth2Refresh(input: Oauth2RefreshInput!): Oauth2TokenOutput!
  oauth2Token(input: Oauth2TokenInput!): Oauth2TokenOutput!
  publishDatasetVersion(datasetVersionId: ID!): DatasetVersion!
  publishVote(id: ID!, kind: VoteKind!): VotableEdge!
  reevaluateCompetitionStage(competitionId: ID!, stage: Int): CompetitionStageEdge!
  remindEventInvitees(eventId: ID!): Event!
  removeCompetitionJury(competitionId: ID!, entityId: ID!): Entity!
  removeCompetitionMember(id: ID!): ID!
  """
  Withdraw currently active leaderboard if it is still empty, making last stage the currently
  active leaderboard. Useful when a new stage was created by error.
  Returns previously staged leaderboard that now became active.
  """
  removeCompetitionStage(stageId: ID!): Competition!
  removeDatasetCompetition(competitionId: ID!, datasetId: ID!): Competition!
  removeDatasetMember(datasetId: ID!, entityId: ID!): ID!
  removeEventCompetition(id: ID!): ID!
  removeEventInviteCode(id: ID!): EventPublicInvite!
  removeEventMember(id: ID!): ID!
  removeOrganizationMember(id: ID!): ID!
  resendEmailSignupVerification(id: ID!): EmailSignupRequest!
  resetDraftDatasetVersion(datasetVersionId: ID!): DatasetVersion!
  resetPassword(input: ResetPasswordInput!): Boolean!
  resetVote(id: ID!): VotableEdge!
  sendCompetitionTeamRequestMessage(competitionTeamRequestId: ID!, message: String!): CompetitionTeamRequest!
  sendEmailSignupVerification(input: SendEmailSignupVerificationInput!): EmailSignupRequest!
  setCompetitionOrderingPriority(id: ID!, priority: Int!): CompetitionEdge!
  setEventOrderingPriority(id: ID!, priority: Int!): EventEdge!
  setUserIsBanned(entityId: ID!, isBanned: Boolean!): User!
  setUserNotificationSubscription(notification: NotificationKind!, subscribe: Boolean!): UserEdge!
  signupUser(input: SignupUserInput!): UserEdge!
  startDatasetVersionUpload(datasetVersionId: ID!): DatasetVersion!
  subscribeToSubject(asEntity: UsernameOrID, subject: ID!): SubjectSubscriptionEdge!
  transferCompetitionOwnership(competitionId: ID!, toEntityId: ID!): [CompetitionMembershipEdge!]!
  transferDatasetOwnership(datasetId: ID!, newOwner: UsernameOrID!): Dataset!
  transferEventOwnership(eventId: ID!, toEntityId: ID!): [EventMembershipEdge!]!
  transferOrganizationOwnership(organizationId: ID!, toUserId: ID!): [OrganizationMembershipEdge!]!
  unsubscribeFromAllNotifications: UserEdge!
  unsubscribeFromSubject(subscription: ID!): ID!
  unsubscribeNotificationForToken(token: String!): NotificationKind
  updateBlogArticle(id: ID!, input: UpdateBlogArticleInput!): BlogArticleEdge!
  updateComment(id: ID!, input: UpdateCommentInput!): CommentEdge!
  updateCompetition(id: ID!, input: UpdateCompetitionInput!): CompetitionEdge!
  updateCompetitionMembership(id: ID!, input: UpdateCompetitionMemberInput!): CompetitionMembership!
  updateCompetitionStage(input: UpdateCompetitionStageInput!, stageId: ID!): CompetitionStageEdge!
  updateCompetitionTeamRequest(competitionTeamRequestId: ID!, input: UpdateCompetitionTeamRequestInput!): CompetitionTeamRequest!
  updateDataset(datasetId: ID!, input: UpdateDatasetInput!): Dataset!
  updateDatasetVersion(datasetVersionId: ID!, input: UpdateDatasetVersionInput!): DatasetVersion!
  updateEvent(id: ID!, input: UpdateEventInput!): EventEdge!
  updateEventAgenda(eventId: ID!, input: UpdateAgendaInput!): EventEdge!
  updateForum(id: ID!, input: UpdateForumInput!): ForumEdge!
  updateOauth2Config(input: UpdateOauth2ConfigInput!, oauth2ConfigId: ID!): Oauth2ConfigEdge!
  updateOrganization(id: ID!, input: UpdateOrganizationInput!): OrganizationEdge!
  updateOrganizationMembership(kind: OrganizationMembershipKind!, organizationId: ID!, userId: ID!): OrganizationMembershipEdge!
  updateProjectVersionApproval(input: ProjectVersionApprovalInput!, projectVersionApprovalId: ID!): ProjectVersionApprovalEdge!
  updateTopic(id: ID!, input: UpdateTopicInput!): Topic!
  updateUser(id: ID!, input: UpdateUserInput!): UserEdge!
  """
  Upload a part of the file that was attached to a dataset version.
  Returns a short-lived URL that you can HTTP PUT.
  May be called any number of times, but at least once.
  """
  uploadDatasetVersionFilePart(datasetVersionFileId: ID!, part: Int!, partSize: Int!): Url!
  """
  Submit files for a "no-code" competition. This feature is not available for regular
  competitions.
  """
  uploadNoCodeSubmissionVersion(asEntity: UsernameOrID, competitionId: ID!, input: UploadNoCodeSubmissionInput!): ProjectVersionEdge!
  uploadProjectVersionFilePart(chunk: Int!, chunkLen: Int!, id: ID!, uploadId: String!): Url!
  validateSubmissionVersion(projectVersionId: ID!): ProjectVersionEdge!
  validateUseCaseVersion(projectVersionId: ID!): ProjectVersionEdge!
  withdrawBadge(id: ID!): ID!
}

"""
ISO 8601 calendar date without timezone.
Format: %Y-%m-%d

# Examples

* `1994-11-13`
* `2000-02-24`
"""
scalar NaiveDate

interface Node {
  id: ID!
}

enum NotificationKind {
  AWARD_BADGE
  CONTENT_MENTIONED
  CREATE_SUBMISSION
  CREATE_TOPIC
  JURY_SELECTED
  PROJECT_VERSION_APPROVAL_CREATED
  PROMOTIONAL_NEWSLETTER
  REPLY_COMMENT
  REPLY_TOPIC
}

enum Oauth2Action {
  LOGGED_IN
  SIGNUP_REQUIRED
}

interface Oauth2AuthResponse {
  action: Oauth2Action!
}

type Oauth2AuthorizationCode {
  code: String!
}

input Oauth2AuthorizeInput {
  clientId: String!
  redirectUri: Url
  scope: String
  state: String
}

type Oauth2AuthorizeOutput {
  clientError: Boolean!
  redirectUri: Url
  unauthorized: Boolean!
}

type Oauth2Config implements Node {
  description: String
  entity: Entity!
  id: ID!
  name: String!
  redirectUri: String!
  secret: String!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type Oauth2ConfigConnection {
  """A list of edges."""
  edges: [Oauth2ConfigEdge!]!
  """A list of nodes."""
  nodes: [Oauth2Config!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type Oauth2ConfigEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Oauth2Config!
}

type Oauth2LoggedIn implements Oauth2AuthResponse {
  action: Oauth2Action!
  user: User!
}

type Oauth2PreGrant {
  clientId: String!
  oauth2Config: Oauth2Config
  redirectUri: Url
  scope: [Scope!]!
  state: String
  valid: Boolean!
}

enum Oauth2Provider {
  GITHUB
  GOOGLE
}

input Oauth2RedirectInput {
  authorizationUrl: Url!
  signature: String!
}

input Oauth2RefreshInput {
  clientId: String!
  clientSecret: String
  refreshToken: String!
}

type Oauth2Signup {
  secret: String!
}

input Oauth2SignupInput {
  secret: String!
}

type Oauth2SignupRequired implements Oauth2AuthResponse {
  action: Oauth2Action!
  oauth2Signup: Oauth2Signup!
  userInfo: Oauth2UserInfo!
}

type Oauth2Token {
  accessToken: String!
  expiresIn: Int!
  refreshToken: String!
  scope: String!
}

input Oauth2TokenInput {
  clientId: String!
  code: String!
  redirectUri: Url!
}

type Oauth2TokenOutput {
  clientError: Boolean!
  issued: Oauth2Token
  unauthorized: Boolean!
}

type Oauth2UserInfo {
  avatarUrl: Url
  bio: String
  email: String!
  name: String
  username: String
}

type Organization implements Entity & Node {
  badges(after: String, before: String, first: Int, last: Int): EntityBadgeConnection!
  bio: String
  createdAt: DateTime!
  datasets(after: String, before: String, filters: DatasetQueryFilters, first: Int, last: Int): DatasetConnection!
  displayName: String!
  github: String
  googleScholar: String
  id: ID!
  image: Url
  imageThumbnail: Url
  kind: EntityKind!
  linkedin: String
  location: String
  points: Int!
  projectVersionApprovals(after: String, before: String, first: Int, last: Int, projectVersionId: UUID): ProjectVersionApprovalConnection!
  rank: Int!
  subjectSubscriptions(after: String, before: String, first: Int, kinds: [SubjectKind!], last: Int): SubjectSubscriptionConnection!
  submissions(after: String, allStages: Boolean, before: String, competitionId: ID, first: Int, last: Int): SubmissionConnection!
  userMembership(user: UsernameOrID): OrganizationMembership
  username: String!
  users(after: String, before: String, first: Int, last: Int): OrganizationUserConnection!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
  website: String
}

type OrganizationConnection {
  """A list of edges."""
  edges: [OrganizationEdge!]!
  """A list of nodes."""
  nodes: [Organization!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type OrganizationEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Organization!
}

type OrganizationMembership implements Node {
  id: ID!
  kind: OrganizationMembershipKind!
  organization: Organization!
  user: User!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

"""An edge in a connection."""
type OrganizationMembershipEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: OrganizationMembership!
}

enum OrganizationMembershipKind {
  ADMIN
  EDITOR
  OWNER
  READER
}

type OrganizationUserConnection {
  """A list of edges."""
  edges: [OrganizationMembershipEdge!]!
  """A list of nodes."""
  nodes: [OrganizationMembership!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Information about pagination in a connection"""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: String
}

type PasswordReset {
  canResendAt: DateTime!
  createdAt: DateTime!
  expiresAt: DateTime!
}

input Permission {
  actingAs: UsernameOrID
  on: ID
  to: Action!
}

interface Project {
  competition: Competition!
  id: ID!
  latest: ProjectVersion
  name: String!
  stage: CompetitionStage!
  version(version: Semver): ProjectVersion
  versions(after: String, before: String, first: Int, last: Int): ProjectVersionConnection!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type ProjectVersion implements Node {
  approval(entity: UsernameOrID): ProjectVersionApproval
  approvals(after: String, before: String, first: Int, last: Int): ProjectVersionApprovalConnection!
  createdAt: DateTime!
  entity: Entity!
  evaluation: ProjectVersionEvaluation
  fileByKind(kind: ProjectVersionFileKind!): ProjectVersionFile
  files: [ProjectVersionFile!]!
  id: ID!
  latest: Boolean!
  project: Project!
  pyprojectToml: String!
  pythonRequires: String
  readme: String
  status: ProjectVersionStatus!
  validatedAt: DateTime
  version: Semver!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type ProjectVersionApproval implements Node {
  accept: Boolean!
  createdAt: DateTime!
  entity: Entity!
  id: ID!
  notes: String
  projectVersion: ProjectVersion!
  scores: [ProjectVersionApprovalScore!]!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

input ProjectVersionApprovalAcceptInput {
  notes: String
  scores: [ProjectVersionApprovalScoreInput!]!
}

type ProjectVersionApprovalConnection {
  """A list of edges."""
  edges: [ProjectVersionApprovalEdge!]!
  """A list of nodes."""
  nodes: [ProjectVersionApproval!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ProjectVersionApprovalEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: ProjectVersionApproval!
}

input ProjectVersionApprovalInput {
  accept: ProjectVersionApprovalAcceptInput
  reject: ProjectVersionApprovalRejectInput
}

input ProjectVersionApprovalRejectInput {
  reason: String!
}

type ProjectVersionApprovalScore implements Node {
  competitionScoringCriterion: CompetitionScoringCriterion!
  id: ID!
  projectVersionApproval: ProjectVersionApproval!
  value: Float
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

input ProjectVersionApprovalScoreInput {
  competitionScoringCriterionId: ID!
  value: Float
}

enum ProjectVersionCompressor {
  GZIP
  ZSTANDARD
}

type ProjectVersionConnection {
  """A list of edges."""
  edges: [ProjectVersionEdge!]!
  """A list of nodes."""
  nodes: [ProjectVersion!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ProjectVersionEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: ProjectVersion!
}

type ProjectVersionEvaluation implements Node {
  createdAt: DateTime!
  error: String
  finalizedAt: DateTime
  id: ID!
  latest: Boolean!
  max: Boolean!
  projectVersion: ProjectVersion!
  score: Float
  submission: Submission!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type ProjectVersionFile implements Node {
  browse: FileBrowser!
  downloadUrl(archKind: ArchiveKind! = TAR): Url!
  extension: String
  id: ID!
  kind: ProjectVersionFileKind!
  projectVersion: ProjectVersion!
  uploadUrl: Url
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

enum ProjectVersionFileKind {
  DATA
  PACKAGE
  SUBMISSION_EVALUATION
  TEMPLATE
}

enum ProjectVersionStatus {
  AWAITING_APPROVAL
  AWAITING_EVALUATION
  AWAITING_VALIDATION
  ERROR
  OK
}

type Query {
  blogArticleBySlug(slug: String!): BlogArticle
  blogArticles(after: String, before: String, first: Int, last: Int): BlogArticleConnection!
  competitionBySlug(slug: String!): Competition
  competitions(after: String, before: String, first: Int, last: Int, search: String): CompetitionConnection!
  datasetBySlug(localSlug: String!, owner: String!): Dataset
  datasets(after: String, before: String, filters: DatasetQueryFilters, first: Int, last: Int): DatasetConnection!
  entities(after: String, before: String, first: Int, kinds: [EntityKind!], last: Int, search: String): EntityConnection!
  entityByUsername(username: String!): Entity
  eventBySlug(slug: String!): Event
  events(after: String, before: String, first: Int, last: Int, search: String): EventConnection!
  forumBySlug(slug: String!): Forum
  forums(after: String, before: String, first: Int, last: Int, search: String): ForumConnection!
  leaderboard(after: String, before: String, first: Int, kinds: [EntityKind!], last: Int, search: String): GlobalLeaderboardConnection!
  node(id: ID!): Node!
  oauth2Authorize(input: Oauth2AuthorizeInput!): Oauth2PreGrant
  oauth2Configs(after: String, before: String, first: Int, last: Int): Oauth2ConfigConnection!
  oauth2Providers: [Oauth2Provider!]!
  tags(after: String, before: String, filters: TagQueryFilters, first: Int, last: Int): TagConnection!
  version: Version!
  viewer: User!
}

input ResetPasswordInput {
  password: String!
  secret: String!
}

enum Scope {
  ALL
  DEFAULT
  READ_COMPETITION
  READ_PROJECT
}

scalar Semver

input SendEmailSignupVerificationInput {
  agreeToTermsAndPrivacyPolicy: Boolean!
  email: String!
  password: String!
}

input SignupInput {
  email: EmailSignupVerficationInput
  oauth2: Oauth2SignupInput
}

input SignupUserInput {
  bio: String
  displayName: String!
  github: String
  googleScholar: String
  image: Upload
  linkedin: String
  location: String
  signup: SignupInput!
  subscribePromotionalNewsletter: Boolean
  username: String!
  website: Url
}

enum SubjectKind {
  COMPETITION
  FORUM
  TOPIC
}

interface SubjectSubscription {
  createdAt: DateTime!
  entity: Entity!
  id: ID!
  kind: SubjectKind!
  subject: Subscribable!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type SubjectSubscriptionConnection {
  """A list of edges."""
  edges: [SubjectSubscriptionEdge!]!
  """A list of nodes."""
  nodes: [SubjectSubscription!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type SubjectSubscriptionEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: SubjectSubscription!
}

type Submission implements Node & Project {
  competition: Competition!
  entity: Entity!
  id: ID!
  latest: ProjectVersion
  maxEvaluation: ProjectVersionEvaluation
  name: String!
  stage: CompetitionStage!
  version(version: Semver): ProjectVersion
  versions(after: String, before: String, first: Int, last: Int): ProjectVersionConnection!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type SubmissionConnection {
  """A list of edges."""
  edges: [SubmissionEdge!]!
  """A list of nodes."""
  nodes: [Submission!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type SubmissionEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Submission!
}

type SubmissionRankingConnection {
  """A list of edges."""
  edges: [SubmissionRankingSubmissionEdge!]!
  """A list of nodes."""
  nodes: [Submission!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type SubmissionRankingSubmissionEdge {
  competition: Competition!
  """A cursor for use in pagination"""
  cursor: String!
  entity: Entity!
  """The item at the end of the edge"""
  node: Submission!
  points: Int!
  projectVersion: ProjectVersion!
  rank: Int!
  score: Float!
  stage: CompetitionStage!
  submission: Submission!
  validatedAt: DateTime!
}

interface Subscribable {
  entitySubscription(entity: UsernameOrID): SubjectSubscription
  id: ID!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type Subscription {
  datasetVersionUpdate(datasetVersionId: ID!): DatasetVersionUpdate!
  deletedComments(topicId: ID): DeletedComment!
  newComments(topicId: ID): CommentEdge!
  oauth2Redirect(input: Oauth2RedirectInput!): Oauth2AuthorizationCode!
  projectVersionStatusUpdate(competitionId: ID, entityId: ID, projectId: ID, projectVersionId: ID): ProjectVersion!
  updatedComments(topicId: ID): CommentEdge!
  updatedEntity(id: ID): Entity!
}

type Tag implements Node {
  id: ID!
  name: String!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type TagConnection {
  """A list of edges."""
  edges: [TagEdge!]!
  """A list of nodes."""
  nodes: [Tag!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type TagEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Tag!
}

input TagQueryFilters {
  activityKind: ActivityKind = null
  search: String
}

scalar TimeZone

type Timeline {
  endDate: NaiveDate!
  id: ID!
  online: Boolean!
  startDate: NaiveDate!
  steps(after: String, before: String, first: Int, last: Int): TimelineStepConnection!
  timezone: TimeZone!
}

type TimelineStep {
  date: NaiveDate!
  id: ID!
  label: String!
}

type TimelineStepConnection {
  """A list of edges."""
  edges: [TimelineStepEdge!]!
  """A list of nodes."""
  nodes: [TimelineStep!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type TimelineStepEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: TimelineStep!
}

input TimelineStepInput {
  date: NaiveDate!
  label: String!
}

type Topic implements Node & Subscribable & Votable {
  author: Entity!
  commentCount: Int!
  comments(after: String, before: String, first: Int, last: Int, order: VotableOrder): CommentConnection!
  createdAt: DateTime!
  description: String
  entitySubscription(entity: UsernameOrID): SubjectSubscription
  forum: Forum!
  id: ID!
  slugLower: String!
  title: String!
  url: String
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
  voted: EntityVote
  voterCount: Int!
  voters(after: String, before: String, first: Int, last: Int): VotersConnection!
  votes: Int!
}

type TopicConnection {
  """A list of edges."""
  edges: [TopicEdge!]!
  """A list of nodes."""
  nodes: [Topic!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type TopicEdge {
  """A cursor for use in pagination"""
  cursor: String!
  hotness: Float!
  """The item at the end of the edge"""
  node: Topic!
}

type TopicSubscription implements Node & SubjectSubscription {
  createdAt: DateTime!
  entity: Entity!
  id: ID!
  kind: SubjectKind!
  subject: Subscribable!
  topic: Topic!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

"""
A UUID is a unique 128-bit number, stored as 16 octets. UUIDs are parsed as
Strings within GraphQL. UUIDs are used to assign unique identifiers to
entities without requiring a central allocating authority.

# References

* [Wikipedia: Universally Unique Identifier](http://en.wikipedia.org/wiki/Universally_unique_identifier)
* [RFC4122: A Universally Unique IDentifier (UUID) URN Namespace](http://tools.ietf.org/html/rfc4122)
"""
scalar UUID

input UnregisteredDatasetVersionAuthorInput {
  fullName: String!
}

type UnregisteredUser implements DatasetVersionAuthor {
  displayName: String!
}

input UpdateAgendaInput {
  agenda: JSON
}

input UpdateBlogArticleInput {
  authorsIds: [ID!]
  content: String
  image: Upload
  imageAlt: String
  seoDescription: String
  seoTitle: String
  shortDescription: String
  title: String
}

input UpdateCommentInput {
  content: String!
}

input UpdateCompetitionInput {
  banner: Upload
  description: String
  """Enables no-code system on competition. Requires jury system to work."""
  noCode: Boolean
  """
  Only allow the competition host, the reviewer and the submission author to see the approval
  score.
  """
  privateApprovals: Boolean
  """Enables jury system on competition"""
  requiresApproval: Boolean
  rules: String
  scoringCriteria: [UpdateCompetitionScoringCriterionInput!]
  shortDescription: String
  """Show automated use-case metric."""
  showMetric: Boolean
  slug: String
  """Message shown to participants before they submit a solution."""
  submissionPreamble: String
  tagIds: [ID]
  thumbnail: Upload
  timeline: UpdateTimelineInput
  title: String
  """
  Use average jury score instead of automated use-case metric. Requires jury system to work.
  """
  useJuryScore: Boolean
  visibility: ActivityVisibility
}

input UpdateCompetitionMemberInput {
  asEntityId: ID
}

input UpdateCompetitionScoringCriterionInput {
  description: String
  id: ID
  title: String!
  weight: Float!
}

input UpdateCompetitionStageInput {
  """Enables no-code system on competition. Requires jury system to work."""
  noCode: Boolean
  """
  Only allow the competition host, the reviewer and the submission author to see the approval
  score.
  """
  privateApprovals: Boolean
  """Enables jury system on competition"""
  requiresApproval: Boolean
  scoringCriteria: [UpdateCompetitionScoringCriterionInput!]
  """Show automated use-case metric."""
  showMetric: Boolean
  """Message shown to participants before they submit a solution."""
  submissionPreamble: String
  """
  Use average jury score instead of automated use-case metric. Requires jury system to work.
  """
  useJuryScore: Boolean
}

input UpdateCompetitionTeamRequestInput {
  needs: String
  skills: String
  timezone: TimeZone
}

input UpdateDatasetInput {
  localSlug: String
  name: String
  private: Boolean
  shortDescription: String
  tags: [ID!]
}

input UpdateDatasetVersionInput {
  authors: [DatasetVersionAuthorInput!]
  description: String
  license: String
  version: Semver
}

input UpdateEventInput {
  banner: Upload
  description: String
  rules: String
  shortDescription: String
  slug: String
  thumbnail: Upload
  title: String
  visibility: ActivityVisibility
}

input UpdateForumInput {
  description: String
  guidelines: String
  icon: Upload
  orderingPriority: Int
  shortDescription: String
  slug: String
  title: String
}

input UpdateOauth2ConfigInput {
  description: String
  name: String
  redirectUri: Url
  refreshSecret: Boolean
}

input UpdateOrganizationInput {
  bio: String
  displayName: String
  github: String
  googleScholar: String
  image: Upload
  inQuantumJob: Boolean
  linkedin: String
  location: String
  username: String
  website: Url
}

input UpdateSubmissionInput {
  compression: ProjectVersionCompressor
  pyprojectToml: String!
  readme: String
}

input UpdateTimelineInput {
  endDate: NaiveDate
  online: Boolean
  startDate: NaiveDate
  steps: [TimelineStepInput!]
  timezone: TimeZone
}

input UpdateTopicInput {
  description: String
  title: String
}

input UpdateUseCaseInput {
  compression: ProjectVersionCompressor
  pyprojectToml: String!
  readme: String
}

input UpdateUserInput {
  bio: String
  displayName: String
  email: String
  github: String
  googleScholar: String
  image: Upload
  inQuantumJob: Boolean
  jobTitle: String
  linkedin: String
  location: String
  oldPassword: String
  organization: String
  password: String
  username: String
  website: Url
}

scalar Upload

input UploadNoCodeSubmissionInput {
  files: [Upload!]!
}

"""
URL is a String implementing the [URL Standard](http://url.spec.whatwg.org/)
"""
scalar Url

type UseCase implements Node & Project {
  competition: Competition!
  id: ID!
  latest: ProjectVersion
  name: String!
  stage: CompetitionStage!
  version(version: Semver): ProjectVersion
  versions(after: String, before: String, first: Int, last: Int): ProjectVersionConnection!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
}

type User implements DatasetVersionAuthor & Entity & Node {
  activities(after: String, before: String, first: Int, kinds: [EntityActivitiesConnectionKind!], last: Int): ActivityConnection!
  badges(after: String, before: String, first: Int, last: Int): EntityBadgeConnection!
  bio: String
  """can this user perform the action on the given resource"""
  can(actingAs: UsernameOrID, action: Action!, on: ID): Boolean!
  comments(after: String, before: String, first: Int, last: Int, order: VotableOrder): CommentConnection!
  createdAt: DateTime!
  datasets(after: String, before: String, filters: DatasetQueryFilters, first: Int, last: Int): DatasetConnection!
  displayName: String!
  email: String!
  entities(after: String, before: String, first: Int, last: Int, permission: Permission, search: String): UserEntitiesConnection!
  github: String
  googleScholar: String
  id: ID!
  image: Url
  imageThumbnail: Url
  isAvailableOnQuantumJobs: Boolean!
  isBanned: Boolean!
  jobBoardProfileLink: Url
  jobTitle: String
  karma: Int!
  kind: EntityKind!
  linkedin: String
  location: String
  notifications: UserNotifications!
  organization: String
  organizations(after: String, before: String, first: Int, last: Int, search: String): UserOrganizationConnection!
  points: Int!
  projectVersionApprovals(after: String, before: String, first: Int, last: Int, projectVersionId: UUID): ProjectVersionApprovalConnection!
  rank: Int!
  subjectSubscriptions(after: String, before: String, first: Int, kinds: [SubjectKind!], last: Int): SubjectSubscriptionConnection!
  submissions(after: String, allStages: Boolean, before: String, competitionId: ID, first: Int, last: Int): SubmissionConnection!
  topics(after: String, before: String, first: Int, last: Int, order: VotableOrder): TopicConnection!
  username: String!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
  website: String
}

"""An edge in a connection."""
type UserEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: User!
}

type UserEntitiesConnection {
  """A list of edges."""
  edges: [EntityEdge!]!
  """A list of nodes."""
  nodes: [Entity!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type UserNotifications {
  disabled: [NotificationKind!]!
  enabled: [NotificationKind!]!
}

type UserOrganizationConnection {
  """A list of edges."""
  edges: [OrganizationMembershipEdge!]!
  """A list of nodes."""
  nodes: [OrganizationMembership!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

scalar UsernameOrID

type Version {
  current: String!
  gitCommit: String
}

interface Votable {
  id: ID!
  viewerCan(action: Action!, asEntity: UsernameOrID): Boolean!
  voted: EntityVote
  voterCount: Int!
  voters(after: String, before: String, first: Int, last: Int): VotersConnection!
  votes: Int!
}

"""An edge in a connection."""
type VotableEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Votable!
}

enum VotableOrder {
  HOT
  NEWEST
  OLDEST
}

enum VoteKind {
  DOWNVOTE
  UPVOTE
}

type VotersConnection {
  """A list of edges."""
  edges: [EntityEdge!]!
  """A list of nodes."""
  nodes: [Entity!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type WebsiteMetadata {
  description: String
  title: String
}